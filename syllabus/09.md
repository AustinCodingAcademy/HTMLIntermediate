# Modules

A small program is usually organized into functions. As a program grows, programmers tend to find new ways to organize their code so that the disparate parts make sense. Modern development uses *modules* to organize code into discrete parts. Typically, those parts will share similar functionality or prescribe some output.

## How modules help

Modules provide a developer a clear structure for code organization. They allow developers not familiar with the code to more easily find functionality because things that are related are close together.

Unless you know exactly how you want to structure your program, it is typically a good idea to start with as little as possible and to refactor and add it as needed, this way you don't commit to a structure ideology that is difficult to get out of.

### Namespacing

Many programming languages have scopes between global and local. Javascript is one that doesn't. In Javascript, everything that isn't hidden inside a function is available everywhere. Having many functions and variables in the global namespace is typically unwanted as it can make values hard to find and increases the risk that function or variable definitions will be accidentally overwritten.

Javascript doesn't yet include any way to define and export modules, but we can use objects and functions to isolate functionality. later, we'll look at how we can build modules using the tools Javascript gives us.

### Reuse

When we aren't using modules, our programs are said to be "flat". One of the biggest drawbacks of a flat program structue is that it makes reuse difficult. For example, we wrote a program to parse an INI file. If we wanted to use some of that code in another program, we'd need to copy and paste that code into our new program. If we then found a bug in that code, we'd need to go back to every instance of that code to fix it.

Once we have many bits of duplicated and shared code, we'll spend a bunch of time copying, pasting, and fixing code in a bunch of different places.

We want to put functionality into separate files and modules which makes them easier to keep track of, update, and share. Then we can start to define dependencies, where one module requires others to work. Putting these together builds libraries. Finally, we can publish and retrieve these modules and libraries online on the [Node Package Manager (NPM)](https://www.npmjs.com/).

###Decoupling

Modules also isolates code from other parts of the program just like object interfaces do. When a module receives an update with bug fixes or new functionality, the interface stays the same or remains *stable* so that other modules and code can continue to use it without making any changes to themselves.

Keeping a module stable doesn't mean that new things may not be added, only that nothing gets removed and what it does doesn't change. A good module interface will allow a module to grow without breaking existing code somewhere else.

## Using functions as namespaces

In Javascript, functions are the only thing that create a new scope.  If we want our modules to have their own scope, we'll need to use functions.

Let's start with a simple module that returns the name of a day of the week as it is returned by `Date.getDay`:

```javascript
var days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
function dayName(number) {
    return days[number];
}
console.log(dayName(3));
// Wednesday
```

We want the `dayName` function to be part of our interface, but not the `days`variable and we don't want that to be global, so let's start by moving it into `dayName`.

```javascript
var dayName = function() {
    var days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    return function(number) {
        return days[number];
    };
}();
console.log(dayName(2));
// Tuesday
```

Now the `days` variable is local to the `dayName` function. Using this pattern, we could have a bunch of variables and they'd all be hidden away form the global scope.

We can use a similar pattern to completely hide away our code from the outside world. The following code logs a message to the console but doesn't provide an interface to connect to:

```javascript
(function() {
    function message(words) { return words; }
    var words = "You'll never find me!";
    console.log(message(words));
})();
// You'll never find me!
```

This code just outputs a simple message, but in a production environment, we might use this pattern to add a method to some prototype or set up a widget on a web page.

This is called an *Immediately Invoked Function Expression* or *IIFE*. This name comes form the fact that it is a function placed within parentheses, becoming an expression. The second set of parentheses invokes the function expression immediately.

## Objects as interfaces

Imagine for a moment that we want to add another function to our day-of-the-week module, this one will convert a day name to a number. We cannot just return the function, so we wrap two functions in an object;

```javascript
var dayFunctions = function() {
    var days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

    return {
        name: function(number) { return days[number]; },
        number: function(day) { return days.indexOf(day); }
    };
}();

console.log(dayFunctions.name(2));
// Tuesday
console.log(dayFunctions.number("Thursday"));
// 4
```

This is a small module, so we can put all the exported modules into one object at the end of the function. In a big program, we'd put these modules near the code they are related to. What we can do instead is define an object (by convention, we name it *exports*), and add properties to it whenever we need to export a new module. In the following example, we have an IIFE that accepts the `exports` object as an argument so that we can add properties to it.

```javascript
(function(exports) {
    var days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    exports.name = function(number) { 
        return days[number]; 
    };
    exports.number = function(day) { 
        return days.indexOf(day); 
    };
})(this.dayFunctions = {});
```

The `this` in this example refers to the global scope, so we are adding the `dayFunctions` object and all its properties in the global scope or more accurately, to the `Window` object.

## Detaching from the global scope

The pattern above is useful for modules that we intend to use in a browser. We grab a global variable and wrap that in a function to protect the scope of the variables we might use within. The biggest problem with this pattern is that we can accidentally, or maybe on purpose, override a variable that already exists.

We could build a system that allows one module to specifically ask for the interface of another module, without keeping everything global. We want a function, maybe called `require` that when we give it a module name, will load that module's file (either from the internet or a local file) and return the interface's value.

This is great because we have to explicitly state our dependencies, meaning it'll be more difficult to accidentally use a module we don't need.

`require` will need two things. First, we need a function called `readFile` that returns the content of a file as a string. Javascript doesn't have any function that does a thing like this, but the browser and Node.js have their ways. Second, we need to be able to evaluate the code.

## Evaluating data as code

Let's look at how we can take a string and evaluate it like it was code.

We can use the Javascript function `eval`. We must be careful with `eval`, as it doesn't provide for a way to sanitize or safely check input.

```javascript
function evalAndReturnX(code) {
    eval(code);
    return x;
}

console.log(evalAndReturnX("var x = 2 * 4"));
// 8
```

OK, so we can wrap a module's code in a function and that function's scope becomes our module scope.

## Require

Let's write a require function:

```javascript
function require(name) {
    var code = new Function("exports", readFile(name));
    var exports = {};
    code(exports);
    return exports;
}

console.log(require("dayFunctions").name(1));
// Monday
```

Here we use the Function constructor instead of an IIFE. We also made `exports` an argument of the module function so we don't have to declare it. This makes our module quite a bit smaller.

```javascript
var days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

exports.day = function(number) {
    return days[number];
};
exports.number = function(day) {
    return days.indexOf(day);
};
```

When we use this pattern, we would typically start be defining a few variables that describe the modules we need to load.

```javascript
var dayFunctions = require("dayFunctions");
var today = require("today");

console.log(dayFunctions.name(today.dayNumber()));
```

This simple example has some problems. It will run and load a module every time we `require` it, and if more than one module requires some specific code, it will be loaded every time.

We can solve this by using another object to store modules as they are loaded. Then that object can return stored modules on subsequent calls.

Second, since we explicitly use the `exports` object, that's all we can ever output. We can't do something like exporting a constructor for a new object.

We would typically handle this by providing modules with a variable `module` that has a property `exports`. This property will initially be an empty object, but we can redefine it to something else.

```javascript
function require(name) {
    if (name in require.cache)
        return require.cache[name];

    var code = new Function("exports, module", readFile(name));
    var exports = {}, module = {exports: exports};
    code(exports, module);

    require.cache[name] = module.exports;
    return module.exports;
}
require.cache = Object.create(null);
```

Now we have a system that allows modules to find each other using a single global variable `require` and use each other without defining a bunch more global variables.

This pattern is called *CommonJS modules*, named for the library that first used it. CommonJS is part of Node.js and it does way more than what we have above and it does it way better, so use that, not this code.

## Slow-loading modules

CommonJS is pretty cool, however if the modules we are loading are on a remote server or there are many of them, it can really slow down our program, because every script that needs to be load holds up rendering of the web page.

To solve this we can use something like *Browserfy* to preprocess our Javascript. It will look at all the code and resolve all the dependencies and merge everything into one big file.

We could also wrap our module in a function that loads the dependencies in the background, then runs our code once they are all ready. This patter is called *Asynchronous Module Definition (AMD)*.

If we wrote our program using AMD, it might look something like this:

```javascript
define(["dayFunctions", "today"], function(dayFunctions, today) {
  console.log(dayFunctions.name(today.dayNumber()));
});
```

The `define` function accepts an array of dependencies that are prerequisites to our module. It will load those in the background or pull them from memory if they are already loaded. Then the second argument defines a function that will run when everything is ready.

Modules that use this must also use the `define` method. Here's our `dayFunctions` in the AMD style.

```javascript
define([], function() {
    var names = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    return {
        name: function(number) { return names[number]; },
        number: function(name) { return names.indexOf(name); }
    };
});
```

Let's look at a minimal implementation of `define`. In it, there is a function call `backgroundReadFile` that we will imagine accepts a filename and a function to call after an AJAX call is completed.

We want to keep track of what modules have been loaded and only run the rest of the code once all our dependencies are ready.

We also have a function called `getModule` which accepts a module name and returns an object that tells `define` when each module is loaded and can continue. It also uses a cache to prevent us from loading a module more than once.

```javascript

var defineCache = Object.create(null);
var currentMod = null;

function getModule(name) {
    if (name in defineCache) {
        return defineCache[name];
    }

    var module = {exports: null, loaded: false, onLoad: []};
    defineCache[name] = module;
    backgroundReadFile(name, function(code) {
        currentMod = module;
        new Function("", code)();
    });
    return module;
}
```



## Interface design

## Summary
