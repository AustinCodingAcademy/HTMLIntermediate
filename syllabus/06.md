# Objects Oriented Javascript

## History



## Methods

Methods are object properties that hold function values. For example:

```javascript
var cow = {};
cow.speak = function(line) {
    console.log(`The cow says, "${line}".`);
};

cow.speak("Moo!");
// The cow says, "Moo!".
```

Methods often need to reference the object they belong to. Methods have access to a special variable called `this` that points to the object its called on.

```javascript
function speak(line) {
    console.log(`The ${this.type} cow says, "${line}".`);
}

var ongoleCow = { type: "Ongole", speak: speak };
var herefordCow = { type: "Hereford", speak: speak };

ongoleCow.speak("I'm sacred.");
// The Ongole cow says, "I'm sacred".
herefordCow.speak("I'm probably tasty!");
```

The code here uses the `this` keyword to reference the type of cow that is speaking.

If we look back at the `apply` and `bind` methods, the first argument in each of those is an object that should become "this". There is another method similar to `apply` called `call`. Whereas `apply` accepts an array, `call` takes arguments like a normal function would.

```javascript
speak.apply(herefordCow, ["Scooby Dooby Doo!"]);
// The Hereford cow says, "Scooby Dooby Doo!".

speak.call({type: "Beefalo"}, "I am confused!");
// The Beefalo cow says, "I am confused!".
```

## Prototypes

Check this out.

```javascript
var empty_obj = {};
console.log(empty_obj.toString);
// function toString() { [native code] }

console.log(empty_obj.toString());
// [object Object]
```

Here, we created an empty object. Then we peeked at the internal code of the `toString` method. Javascript told us it was some native code. When we ran the method, it returned an object. So, what's happening here? In addition to properties and methods, objects have a `prototype`. A prototype is an object that is used as a fall back source for properties. When we request a property from an object that doesn't exist, its prototype object will be searched, and that object's prototype will be searched, and on and on.

Nearly all objects inherit from `Object.prototype`. We can demonstrate this by comparing the prototype of an empty object with the prototype of the base Object object.

```javascript
console.log(Object.getPrototypeOf({}) === Object.prototype);
```

We use `Object.getPrototypeOf` to return the prototype of an object. We can see that `Object.prototype` has no parent object by running some code:

```javascript
console.log(Object.getPrototypeOf(Object.prototype));
// null
```

The prototypical relationship between objects in Javascript creates a sort of tree, with `Object.prototype` forming the base. It provides a bunch of methods that are then inherited by other objects. Most objects don't inherit directly from `Object.prototype`, but rather from other objects that provide their own properties.

```javascript
console.log(Object.getPrototypeOf(isNaN) === Function.prototype);
// true
console.log(Object.getPrototypeOf([]) === Array.prototype);
// true
```

Both Function.prototype and Array.prototype have prototypes, Object.prototype, so that they can implement methods such as `toString`.

The method `Object.getPrototypeOf` returns the prototype of an object and you can use `Object.create` to create an object with a specific prototype.

```javascript
var cowPrototype = {
    speak: function(line) {
        console.log(`The ${this.type} cow says, "${line}".`);
    }
}

var superCow = Object.create(cowPrototype);
superCow.type = "flying";
superCow.speak("I'M THE KING OF THE WORLD!");
// The flying cow says, "I'M THE KING OF THE WORLD!".
```
The `cowPrototype` acts as a container for all the properties shared among different cows. Each cow object contains properties that apply only to itself and derives shared properties from its prototype.

## Constructors

We could use `Object.create` to build a new object, but a better way may be to use a *constructor*. In Javascript, calling a function with the `new` keyword causes it to be treated as a constructor. A constructor will have its `this` variable bound to the new object and unless it explicitly returns a different object value, the new object will be returned too.

An object created with `new` is called an instance of its constructor.

Let's look at a simple constructor for cows. Best practices and coding conventions call for names of constructors to be in [Pascal Case](http://c2.com/cgi/wiki?PascalCase).

```javascript
function Cow(type) {
    this.type = type;
}

var magicCow = new Cow("magical");
var chocolateCow = new Cow("delicious");

console.log(magicCow.type);
// magical
```

Constructors and all functions automatically get a property named `prototype` that holds an empty object inherited from `Object.prototype`. Each instance initiated with this constructor will also have this object in its prototype. That means we can add the `speak` method to every Cow like this:

```javascript
Cow.prototype.speak = function(line) {
    console.log(`The ${this.type} cow says, "${line}".`)
}

magicCow.speak("Hokus Pokus");
// The magical cow says, "Hokus Pokus".
```

## Overriding derived properties

When we add a property to an object, the property is added only to that instance of the object. If there is a prototype of that property, it will remain unchanged.

```javascript
Cow.prototype.horns = "long";
console.log(magicCow.horns);
// long
magicCow.horns = "twinkly";
console.log(magicCow.horns);
// twinkly
console.log(chocolateCow.horns);
// long
console.log(Cow.prototype.horns);
// long
```

Overriding properties allows us to express default property values for generic object prototypes and to set special overrides for specific exceptions.

It is also used to give functions and arrays different implementations of the `toString` method.

```javascript
console.log(Array.prototype.toString === Object.prototype.toString);

console.log([1, 2].toString());
// 1,2
```

Calling `toString` on an array acts similarly to calling the `join` method. We can also call the object version of `toString` with an array. This doesn't work though, because `Object.toString` doesn't understand how to handle arrays.

```javascript
console.log(Object.prototype.toString.call([1, 2]));
// "[object Array]"
```

## Prototype Interference

We can use a prototype at any time to add properties and methods to the objects based on it. For example, we can add a property to the base object and any object that inherits from it will get that property too.

```javascript
Object.prototype.legs = 100;
console.log(ongoleCow.legs);
// 100
```

There are, of course, situations where this behavior is undesirable.

Say we have a different object, we can see all the user defined properties in an object using a `for...in` loop.

```javascript
var Rob = {
    hair: "Brown",
    eyes: "Brown",
};
for (var name in Rob) {
    console.log(name);
}
// hair
// eyes
// legs
console.log("legs" in Rob);
// true
console.log("toString" in Rob);
// true
```

Notice the legs property inherited from the base Object in the Rob object? It doesn't make sense for Rob's 100 legs to be in the output set of data. It looks like the `Object.toString` method is there too, but it wasn't in the list, what's the deal with that? It turns out Javascript can distinguish between *enumerable* and *nonenumerable* properties.

Whenever we define a property in an object, it is enumerable by default and all the properties of `Object.prototype` are nonenumerable.

We can define our own nonenumerable properties using the `Object.defineProperty` function.

```javascript
Object.defineProperty(Object.prototype, "hidden_minutes", {enumerable: false, value: 525600});
console.log(Rob.hidden_minutes);
// 525600
for (var name in Rob) {
    console.log(name);
}
// hair
// eyes
// legs
console.log("hidden_minutes" in Rob);
// true
```

This way, we added the property `hidden_minutes` but it doesn't show up in the loop. However, we still get `true` when we check if the property is `in` the object. We could instead check if the object `hasOwnProperty`.

```javascript
console.log(Rob.hasOwnProperty("hidden_minutes"));
// false
```

This method tells us if the object *itself* has a property set, but ignores its prototypes. If you think that some code in your program might mess with `Object.prototype`, you can write your `for...in` loops like this:

```javascript
for (var name in Rob) {
    if (Rob.hasOwnProperty(name)) {
        console.log(name);
    }
}
// hair
// eyes
```

## Prototype-less objects



## Polymorphism



## Laying out a table



## Getters and setters



## Inheritance



## The instanceof operator



## Summary



## Exercises



