# Objects Oriented Javascript

## History



## Methods

Methods are object properties that hold function values. For example:

```javascript
var cow = {};
cow.speak = function(line) {
    console.log(`The cow says, "${line}".`);
};

cow.speak("Moo!");
// The cow says, "Moo!".
```

Methods often need to reference the object they belong to. Methods have access to a special variable called `this` that points to the object its called on.

```javascript
function speak(line) {
    console.log(`The ${this.type} cow says, "${line}".`);
}

var ongoleCow = { type: "Ongole", speak: speak };
var herefordCow = { type: "Hereford", speak: speak };

ongoleCow.speak("I'm sacred.");
// The Ongole cow says, "I'm sacred".
herefordCow.speak("I'm probably tasty!");
```

The code here uses the `this` keyword to reference the type of cow that is speaking.

If we look back at the `apply` and `bind` methods, the first argument in each of those is an object that should become "this". There is another method similar to `apply` called `call`. Whereas `apply` accepts an array, `call` takes arguments like a normal function would.

```javascript
speak.apply(herefordCow, ["Scooby Dooby Doo!"]);
// The Hereford cow says, "Scooby Dooby Doo!".

speak.call({type: "Beefalo"}, "I am confused!");
// The Beefalo cow says, "I am confused!".
```

## Prototypes

Check this out.

```javascript
var empty_obj = {};
console.log(empty_obj.toString);
// function toString() { [native code] }

console.log(empty_obj.toString());
// [object Object]
```

Here, we created an empty object. Then we peeked at the internal code of the `toString` method. Javascript told us it was some native code. When we ran the method, it returned an object. So, what's happening here? In addition to properties and methods, objects have a `prototype`. A prototype is an object that is used as a fall back source for properties. When we request a property from an object that doesn't exist, its prototype object will be searched, and that object's prototype will be searched, and on and on.

Nearly all objects inherit from `Object.prototype`. We can demonstrate this by comparing the prototype of an empty object with the prototype of the base Object object.

```javascript
console.log(Object.getPrototypeOf({}) === Object.prototype);
```

We use `Object.getPrototypeOf` to return the prototype of an object. We can see that `Object.prototype` has no parent object by running some code:

```javascript
console.log(Object.getPrototypeOf(Object.prototype));
// null
```

The prototypical relationship between objects in Javascript creates a sort of tree, with `Object.prototype` forming the base. It provides a bunch of methods that are then inherited by other objects. Most objects don't inherit directly from `Object.prototype`, but rather from other objects that provide their own properties.

```javascript
console.log(Object.getPrototypeOf(isNaN) === Function.prototype);
// true
console.log(Object.getPrototypeOf([]) === Array.prototype);
// true
```

Both Function.prototype and Array.prototype have prototypes, Object.prototype, so that they can implement methods such as `toString`.

The method `Object.getPrototypeOf` returns the prototype of an object and you can use `Object.create` to create an object with a specific prototype.

```javascript
var cowPrototype = {
    speak: function(line) {
        console.log(`The ${this.type} cow says, "${line}".`);
    }
}

var superCow = Object.create(cowPrototype);
superCow.type = "flying";
superCow.speak("I'M THE KING OF THE WORLD!");
// The flying cow says, "I'M THE KING OF THE WORLD!".
```
The `cowPrototype` acts as a container for all the properties shared among different cows. Each cow object contains properties that apply only to itself and derives shared properties from its prototype.

## Constructors

We could use `Object.create` to build a new object, but a better way may be to use a *constructor*. In Javascript, calling a function with the `new` keyword causes it to be treated as a constructor. A constructor will have its `this` variable bound to the new object and unless it explicitly returns a different object value, the new object will be returned too.

An object created with `new` is called an instance of its constructor.

Let's look at a simple constructor for cows. Best practices and coding conventions call for names of constructors to be in [Pascal Case](http://c2.com/cgi/wiki?PascalCase).

```javascript
function Cow(type) {
    this.type = type;
}

var magicCow = new Cow("magical");
var chocolateCow = new Cow("delicious");

console.log(magicCow.type);
// magical
```

Constructors and all functions automatically get a property named `prototype` that holds an empty object inherited from `Object.prototype`. Each instance initiated with this constructor will also have this object in its prototype. That means we can add the `speak` method to every Cow like this:

```javascript
Cow.prototype.speak = function(line) {
    console.log(`The ${this.type} cow says, "${line}".`)
}

magicCow.speak("Hokus Pokus");
// The magical cow says, "Hokus Pokus".
```

## Overriding derived properties

When we add a property to an object, the property is added only to that instance of the object. If there is a prototype of that property, it will remain unchanged.

```javascript
Cow.prototype.horns = "long";
console.log(magicCow.horns);
// long
magicCow.horns = "twinkly";
console.log(magicCow.horns);
// twinkly
console.log(chocolateCow.horns);
// long
console.log(Cow.prototype.horns);
// long
```

Overriding properties allows us to express default property values for generic object prototypes and to set special overrides for specific exceptions.

It is also used to give functions and arrays different implementations of the `toString` method.

```javascript
console.log(Array.prototype.toString === Object.prototype.toString);

console.log([1, 2].toString());
// 1,2
```

Calling `toString` on an array acts similarly to calling the `join` method. We can also call the object version of `toString` with an array. This doesn't work though, because `Object.toString` doesn't understand how to handle arrays.

```javascript
console.log(Object.prototype.toString.call([1, 2]));
// "[object Array]"
```

## Prototype Interference

We can use a prototype at any time to add properties and methods to the objects based on it. For example, we can add a property to the base object and any object that inherits from it will get that property too.

```javascript
Object.prototype.legs = 100;
console.log(ongoleCow.legs);
// 100
```

There are, of course, situations where this behavior is undesirable.

Say we have a different object, we can see all the user defined properties in an object using a `for...in` loop.

```javascript
var Rob = {
    hair: "Brown",
    eyes: "Brown"
};
for (var name in Rob) {
    console.log(name);
}
// hair
// eyes
// legs
console.log("legs" in Rob);
// true
console.log("toString" in Rob);
// true
```

Notice the legs property inherited from the base Object in the Rob object? It doesn't make sense for Rob's 100 legs to be in the output set of data. It looks like the `Object.toString` method is there too, but it wasn't in the list, what's the deal with that? It turns out Javascript can distinguish between *enumerable* and *nonenumerable* properties.

Whenever we define a property in an object, it is enumerable by default and all the properties of `Object.prototype` are nonenumerable.

We can define our own nonenumerable properties using the `Object.defineProperty` function.

```javascript
Object.defineProperty(Object.prototype, "hidden_minutes", {enumerable: false, value: 525600});
console.log(Rob.hidden_minutes);
// 525600
for (var name in Rob) {
    console.log(name);
}
// hair
// eyes
// legs
console.log("hidden_minutes" in Rob);
// true
```

This way, we added the property `hidden_minutes` but it doesn't show up in the loop. However, we still get `true` when we check if the property is `in` the object. We could instead check if the object `hasOwnProperty`.

```javascript
console.log(Rob.hasOwnProperty("hidden_minutes"));
// false
```

This method tells us if the object *itself* has a property set, but ignores its prototypes. If you think that some code in your program might mess with `Object.prototype`, you can write your `for...in` loops like this:

```javascript
for (var name in Rob) {
    if (Rob.hasOwnProperty(name)) {
        console.log(name);
    }
}
// hair
// eyes
```

## Prototype-less objects

Sometimes we want to create an object without a constructor. In those events, we can use the `Object.create` function and pass it a `null` value.

```javascript
var Puppy = Object.create(null);
Puppy["name"] = "Spot";
console.log("toString" in Puppy);
// false
console.log("pizza" in Puppy);
// true
```

This is great because the only properties this object has are the ones explicitly assigned to it. That means we don't have to muck around with `hasOwnProperty` in our for loops, even if someone has done something to `Object.property`.

## Polymorphism

When you invoke the 'String' function to convert a value to a string on an object, it calls the `toString` method on that object to try to produce something with meaning. Some of the standard prototypes implement their own version of `toString` so that they can output something better than `[object Object]`.

We call a programming language's ability to process objects differently based on the type of data passed to it and the ability to override and modify those processes *polymorphism*.

### Laying out a table

We are going to work through a longer, more involved example where we learn more about polymorphism. We are going to write a program that takes an array of arrays and outputs a formatted table with straight columns and even rows.

Our program will look through all the data to determine the width of each column and the height of each row. We'll then size all the cells and put the data strings in the cells.

As the program evolves, we will be able to add additional styles without breaking the functionality that exists already.

Here is the interface:

* `minHeight()` returns a number indicating the minimum height this cell requires (in lines).
* `minWidth()` returns a number indicating this cell's minimum width (in characters).
* `draw(width, height)` returns an array of length `height`, which contains a series of strings that are each `width` characters wide. This represents the content of the cell.

We are going to use high-order functions a bunch because they'll make the code a bit easier to read and that's what they're here for.

Let's start with some data.

```javascript
var PLANETS = [
    {"Planet": "Mercury", "Earth masses": 0.055, "Composition": "Rock"},
    {"Planet": "Venus", "Earth masses": 0.815, "Composition": "Rock/Gas"},
    {"Planet": "Earth", "Earth masses": 1, "Composition": "Rock"},
    {"Planet": "Mars", "Earth masses": 0.107, "Composition": "Rock"},
    {"Planet": "Jupiter", "Earth masses": 317.8, "Composition": "Gas"},
    {"Planet": "Saturn", "Earth masses": 95.16, "Composition": "Gas"},
    {"Planet": "Uranus", "Earth masses": 14.54, "Composition": "Gas"},
    {"Planet": "Neptune", "Earth masses": 17.15, "Composition": "Gas"}
];
```

The few functions create arrays with the minimum widths of columns and heights of rows for the output grid. The `rows` variable will hold an array of arrays, each inner array represents a row a cells.

```javascript
function rowHeights(rows) {
    return rows.map(function(row) {
        return row.reduce(function(max, cell) {
            return Math.max(max, cell.minHeight());
        }, 0);
    });
}

function colWidths(rows) {
    return rows[0].map(function(_, i) {
        return rows.reduce(function(max, row) {
            return Math.max(max, row[i].minWidth());
        }, 0);
    });
}
```

When we use a variable starting with or consisting only of an underscore (_), we are indicating to someone that will read the code in the future that that variable is not intended to be used.

The `rowHeights` function uses `reduce` compute the biggest height of an array of cells and wraps that in `map` to repeat that for each row in the `rows` array.

`colWidths` is a little more difficult because the outer array is an array of rows, not columns. When we call `map` here, we pass it a second variable which represents the index of the current element. By mapping over the elements in the first row and only using the second argument, `colWidths` builds an array with one element from each column index. In this case, `reduce` runs through the outer `rows` array for each index and grabs the width of the widest cell.

Next is the code to draw the table.

```javascript
function drawTable(rows) {
    var heights = rowHeights(rows);
    var widths = colWidths(rows);

    function drawLine(blocks, lineNo) {
        return blocks.map(function(block) {
            return block[lineNo];
        }).join(" ");
    }

    function drawRow(row, rowNum) {
        var blocks = row.map(function(cell, colNum) {
            return cell.draw(widths[colNum], heights[rowNum]);
        });
        return blocks[0].map(function(_, lineNo) {
            return drawLine(blocks, lineNo);
        }).join("\n");
    }

    return rows.map(drawRow).join("\n");
}
```

## Getters and setters



## Inheritance



## The instanceof operator



## Summary



## Exercises



