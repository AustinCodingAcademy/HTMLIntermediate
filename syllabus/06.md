# Objects Oriented Javascript

## History



## Methods

Methods are object properties that hold function values. For example:

```javascript
var cow = {};
cow.speak = function(line) {
    console.log(`The cow says, "${line}".`);
};

cow.speak("Moo!");
// The cow says, "Moo!".
```

Methods often need to reference the object they belong to. Methods have access to a special variable called `this` that points to the object its called on.

```javascript
function speak(line) {
    console.log(`The ${this.type} cow says, "${line}".`);
}

var ongoleCow = { type: "Ongole", speak: speak };
var herefordCow = { type: "Hereford", speak: speak };

ongoleCow.speak("I'm sacred.");
// The Ongole cow says, "I'm sacred".
herefordCow.speak("I'm probably tasty!");
```

The code here uses the `this` keyword to reference the type of cow that is speaking.

If we look back at the `apply` and `bind` methods, the first argument in each of those is an object that should become "this". There is another method similar to `apply` called `call`. Whereas `apply` accepts an array, `call` takes arguments like a normal function would.

```javascript
speak.apply(herefordCow, ["Scooby Dooby Doo!"]);
// The Hereford cow says, "Scooby Dooby Doo!".

speak.call({type: "Beefalo"}, "I am confused!");
// The Beefalo cow says, "I am confused!".
```

## Prototypes

Check this out.

```javascript
var empty_obj = {};
console.log(empty_obj.toString);
// function toString() { [native code] }

console.log(empty_obj.toString());
// [object Object]
```

Here, we created an empty object. Then we peeked at the internal code of the `toString` method. Javascript told us it was some native code. When we ran the method, it returned an object. So, what's happening here? In addition to properties and methods, objects have a `prototype`. A prototype is an object that is used as a fall back source for properties. When we request a property from an object that doesn't exist, its prototype object will be searched, and that object's prototype will be searched, and on and on.

Nearly all objects inherit from `Object.prototype`. We can demonstrate this by comparing the prototype of an empty object with the prototype of the base Object object.

```javascript
console.log(Object.getPrototypeOf({}) === Object.prototype);
```

We use `Object.getPrototypeOf` to return the prototype of an object. We can see that `Object.prototype` has no parent object by running some code:

```javascript
console.log(Object.getPrototypeOf(Object.prototype));
// null
```

The prototypical relationship between objects in Javascript creates a sort of tree, with `Object.prototype` forming the base. It provides a bunch of methods that are then inherited by other objects. Most objects don't inherit directly from `Object.prototype`, but rather from other objects that provide their own properties.

```javascript
console.log(Object.getPrototypeOf(isNaN) === Function.prototype);
// true
console.log(Object.getPrototypeOf([]) === Array.prototype);
// true
```

Both Function.prototype and Array.prototype have prototypes, Object.prototype, so that they can implement methods such as `toString`.

The method `Object.getPrototypeOf` returns the prototype of an object and you can use `Object.create` to create an object with a specific prototype.

```javascript
var cowPrototype = {
    speak: function(line) {
        console.log(`The ${this.type} cow says, "${line}".`);
    }
}

var superCow = Object.create(cowPrototype);
superCow.type = "flying";
superCow.speak("I'M THE KING OF THE WORLD!");
// The flying cow says, "I'M THE KING OF THE WORLD!".
```
The `cowPrototype` acts as a container for all the properties shared among different cows. Each cow object contains properties that apply only to itself and derives shared properties from its prototype.

## Constructors

We could use `Object.create` to build a new object, but a better way may be to use a *constructor*. In Javascript, calling a function with the `new` keyword causes it to be treated as a constructor. A constructor will have its `this` variable bound to the new object and unless it explicitly returns a different object value, the new object will be returned too.

An object created with `new` is called an instance of its constructor.

Let's look at a simple constructor for cows. Best practices and coding conventions call for names of constructors to be in [Pascal Case](http://c2.com/cgi/wiki?PascalCase).

```javascript
function Cow(type) {
    this.type = type;
}

var magicCow = new Cow("magical");
var chocolateCow = new Cow("delicious");

console.log(magicCow.type);
// magical
```

## Overriding derived properties



## Prototype interference



## Prototype-less objects



## Polymorphism



## Laying out a table



## Getters and setters



## Inheritance



## The instanceof operator



## Summary



## Exercises



