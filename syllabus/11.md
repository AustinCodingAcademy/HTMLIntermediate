# Handling Events

Some programs need to handle user input, things like keyboard and mouse interaction.

## Event handlers

The way we watch for browser interaction events is by *registering handlers*.

```html
<p>Click this document to activate the handler.</p>
<script>
addEventListener("click", function() {
    alert("How can you click?!");
});
</script>
```

We can use the `addEventListener` function by passing it two arguments, the event to watch for and what to do when  that event is triggered.

## Events and DOM nodes

When we call `addEventListener` like we did above, it is being called on the global scope, or on the `window`. Every node element has `addEventListener` available to it too.

```html
<button>Click me</button>
<p>No handler here.</p>
<script>
var button = document.querySelector("button");
button.addEventListener("click", function() {
    alert("Button clicked.");
});
</script>
```

Here we add the `addEventListener` method to the button. This way, clicks on the button register, but everything else doesn't.

We *could* use the `onClick` in place of `addEventListener` with "click" as an argument, however an element may only have one `onClick` attribute, whereas it can have multiple event listeners, which becomes very important when we need to support multiple browsers.

In addition to `addEventListener`, we have `removeEventListener`, which accepts the same aruments as `addEventListener`.

```html
<button>Alert me once!</button>
<script>
    var button = document.querySelector("button");
    function once() {
        alert("I am alerting you.");
        button.removeEventListener("click", once);
    }
    button.addEventListener("click", once);
</script>
```

## Event objects

In the past examples, we've ignored that the function we pass to `addEventListener` accepts an argument that is an object that tells us some useful stuff about what is happening with that event.

```html
<button>Click me baby one more time</button>
<script>
var button = document.querySelector("button");
button.addEventListener("mousedown", function(event) {
    console.log(event);
    if (event.which == 1) {
        console.log("Left button");
    } else if (event.which == 2) {
        console.log("Middle button");
    } else if (event.which == 3) {
        console.log("Right button");
    }
});
</script>
```

The property values in the event object will be different based on the type of event we are watching for.

## Propagation

Event handlers registered on nodes that have children will sometimes receive events that occur on those children. If we have a button inside a paragraph, clicks on the button will register on the event handler for the paragraph, if there is one.

In the event that both the button and the paragraph have event handlers, the most specific one happens first. Clicking the button would cause the click handler for the button to fire, then the click handler for the paragraph would fire. This will continue to happen all the way up the node tree until it get to the `window`. 

We can stop this by having one of the event handlers call `stopPropagation` on the event object to prevent handlers further up the node tree from receiving the event.

In the following example, we register an event on the paragraph and on the button. When the button is clicked with the left button, both handlers fire, but when right-clicked, only the button fires.

```html
<p>A paragraph with a <button>button</button>.</p>
<script>
var para = document.querySelector("p");
var button = document.querySelector("button");
para.addEventListener("mousedown", function() {
    console.log("Handler for paragraph.");
});
button.addEventListener("mousedown", function(event) {
    console.log("Handler for button.");
    if (event.which == 3) {
        event.stopPropagation();
    }
});
</script>
```

Most event objects have a `target` property that refers to the node where they originated. We can use this property to ensure that we're not accidentally handling something that propagated up from a node we do not want to handle.

We can also use the target property to cast a wide net for a specific type of event. For example, if we have a node containing a long list of buttons, it may be more convenient to register a single click handler on the outer node and have it use the target property to figure out whether a button was clicked, rather than register individual handlers on all of the buttons.

```html
<button>A</button>
<button>B</button>
<button>C</button>
<script>
document.body.addEventListener("click", function(event) {
    if (event.target.nodeName == "BUTTON") {
        console.log("Clicked", event.target.textContent);
    }
});
</script>
```

## Default actions

Many events have a default action associated with them. If we click a link, we will be taken to the link's target. If we press the down arrow, the browser will scroll the page down. If we right-click, we'll get a context menu. And so on.

In most cases, the registered handler is called before the default handler. In the event we don't want the default behavior, we can call `preventDefault` on the event object.

```html
<a href="http://google.com/">Google</a>
<script>
var link = document.querySelector("a");
link.addEventListener("click", function(event) {
    alert("Not gonna go there.");
    event.preventDefault();
});
</script>
```

Remember, taking away a users' control is an evil thing to do that will only make people hate you, so use `preventDefault` judiciously.

## Key events

When a key on the keyboard is pressed, your browser fires a `keydown` event. When it is released, a `keyup` event fires.

```html
<p>This page turns violet when you hold the V key.</p>
<script>
addEventListener("keydown", function(event) {
    if (event.keyCode === 86) {
        document.body.style.background = "violet";
    }
});
addEventListener("keyup", function(event) {
    if (event.keyCode === 86) {
        document.body.style.background = "";
    }
});
</script>
```

`keydown` doesn't only fire when we press it. If we hold it down, it would fire repeatedly. This means we must be mindful in the event that we are counting on someone pressing and holding a button.

The `keyCode` associated with keyboard presses are determined by their ascii unicode value (see: http://www.ascii-code.com).

Modifier keys such as Shift, Ctrl, Alt, and Command generate key events just like normal keys. But when looking for key combinations, you can also find out whether these keys are held down by looking at the `shiftKey`, `ctrlKey`, `altKey`, and `metaKey` properties of keyboard and mouse events.

`keydown` is pretty ok, but there is another way to get the value of a key press, its called `keypress`! The `keypress` event fires immediately after `keydown` for keys that produce character input. The `charCode` property in the event object contains a code that can be interpreted as a Unicode character code. We can use the `String.fromCharCode` function to turn this code into an actual single-character string.

```html
<p>Focus this page and type something.</p>
<script>
addEventListener("keypress", function(event) {
    console.log(event.charCode, String.fromCharCode(event.charCode));
});
</script>

```

## Mouse clicks

Pressing a mouse button causes several events to fire. `mousedown` and `mouseup` fire when a mouse is clicked and unclicked. After the `mouseup` event fires, a `click` event fires.

Two clicks in quick succession fire the `dblclick` event.

If we want to know exactly where a user clicked, we can access the event's `pageX` and `pageY` properties.

Let's make a simple drawing program:

```html
<style>
body {
    height: 100%;
    background: beige;
}
.dot {
    height: 8px; width: 8px;
    border-radius: 4px; /* rounds corners */
    background: blue;
    position: absolute;
}
</style>
<script>
addEventListener("click", function(event) {
    var dot = document.createElement("div");
    dot.className = "dot";
    dot.style.left = (event.pageX - 4) + "px";
    dot.style.top = (event.pageY - 4) + "px";
    document.body.appendChild(dot);
});
</script>
```

The `clientX` and `clientY` properties are similar to `pageX` and `pageY` but relative to the part of the document that is currently scrolled into view. These can be useful when comparing mouse coordinates with the coordinates returned by `getBoundingClientRect`, which also returns viewport-relative coordinates.

## Mouse motion

Every time the mouse moves, a `mousemove` event fires. We can use this even to track the position of the mouse. This is commonly used for draggable interactions.

```html
<p>Drag the bar to change its width:</p>
<div style="background: orange; width: 60px; height: 20px"></div>

<script>
var lastX; // Tracks the last observed mouse X position
var rect = document.querySelector("div");
rect.addEventListener("mousedown", function(event) {
    if (event.which == 1) {
        lastX = event.pageX;
        addEventListener("mousemove", moved);
        event.preventDefault(); // Prevent selection
    }
});

function buttonPressed(event) {
    if (event.buttons == null) {
        return event.which != 0;
    } else {
        return event.buttons != 0;
    }
}

function moved(event) {
    if (!buttonPressed(event)) {
        removeEventListener("mousemove", moved);
    } else {
        var dist = event.pageX - lastX;
        var newWidth = Math.max(10, rect.offsetWidth + dist);
        rect.style.width = newWidth + "px";
        lastX = event.pageX;
    }
}
</script>
```

We register `mousemove` on the whole window so that if our cursor exits the resizable box, resizing still works.

We want to stop resizing when a user releases their mouse button. Unfortunately, not all browsers provide `mousemove` with useful "`which`" properties. Lucky for us, all browsers do give either "`which`" or "`buttons`", so we try one and then the other  to get some meaningful information.

When a mouse cursor enters or leaves a node element, it fires the `mouseover` and `mouseout` events. We can use these events to do things to nodes on hover.

Doing this provides many opportunities for problems though, because when we move from a parent node to a child node, `mouseout` fires, even though we haven't left the parent. Plus, this event propagates so when we leave a child node, `mouseout` fires again.

We fortunately have the `relatedTarget` property to look at when hovering in and out of nodes. In the case of `mouseover`, we are told what element the pointer was over before and for `mouseout`, we are told what element it is going to. We'll want to change our hover effect only when the `relatedTarget` is outside of our target node.

```html
<p>Hover over this <strong>paragraph</strong>.</p>
<script>
var para = document.querySelector("p");
function isInside(node, target) {
    for (; node != null; node = node.parentNode) {
        if (node == target) return true;
    }
}
para.addEventListener("mouseover", function(event) {
    if (!isInside(event.relatedTarget, para)) {
        para.style.color = "red";
    }
});
para.addEventListener("mouseout", function(event) {
    if (!isInside(event.relatedTarget, para)) {
        para.style.color = "";
    }
});
</script>
```

The `isInside` function traverses up the given node's parent links until it either reaches the top of the `document` (when node becomes null) or finds the parent we are looking for.

In the case of this example, we'd be better suited by using CSS styles to change the color, but there are some times where we'd want to useJavascript to track hovering.

## Scroll events

Whenever something in the browser is scrolled, the `scroll` event fires. We can use this for all sorts of scroll-related magic.

Let's created a page with a progress bar that fills up as we scroll down the page.

```html
<style>
.progress {
    border: 1px solid blue;
    position: fixed;
    top: 10px; right: 10px;
    width: 100px;
}
.progress > div {
    background: blue;
    height: 12px;
    width: 0%;
}
body {
    height: 2000px;
}
</style>

<div class="progress"><div></div></div>
<p>Scroll me...</p>

<script>
var bar = document.querySelector(".progress div");
addEventListener("scroll", function() {
    var max = document.body.scrollHeight - innerHeight;
    var percent = (pageYOffset / max) * 100;
    bar.style.width = percent + "%";
});
</script>
```

We fix the progress bar to the upper-right so that is stays there while we scroll and use precentages to size the bar as we scroll down.

The global variable `innerHeight` gives us the height of the window, and we subtract that from the total scrollable height. Then, we divide `pageYOffset`, the current scroll position, by the maximum scroll position and multiplying by 100, we get the percentage for the progress bar.

## Focus events

When an element gains focus, usually by clicking or tabbing into it, the browser files a `focus` event. When the element loses focus, the `blur` event fires.

Unlike the other events we've covered, `focus` and `blur` don't propagate. Handlers on the parent node do not fire when a child node gains or loses focus.

```html
<p>Name: <input type="text" data-help="Your full name"></p>
<p>Age: <input type="text" data-help="Age in years"></p>
<p id="help"></p>

<script>
var help = document.querySelector("#help");
var fields = document.querySelectorAll("input");
for (var i = 0; i < fields.length; i++) {
    fields[i].addEventListener("focus", function(event) {
        var text = event.target.getAttribute("data-help");
        help.textContent = text;
    });
    fields[i].addEventListener("blur", function(event) {
        help.textContent = "";
    });
}
</script>
```

When a user switches in or out of a tab, the `focus` and `blur` events file on the window object.

## Load event

When a page finishes loading, the `load` event fires on the window and document body objects. We typically use this to schedule the things we want ot run after the whole document is loaded.

Elements that load external files, such as images and scripts fire `load` events when the file is loaded. `load` events do not propagate.

When a user navigates away from a page or closes a tab, the `beforeunload` event fires. This is useful for preventing someone from losing unsaved work on something by closing a document. When using `beforeunload`, we don't use the `preventDefault` method like in other events. Instead, the even handle returns a string that is used as part of a confirmation message displayed to a user to confirm or deny that they are ready to leave.

## Script execution timeline

## Setting timers

Similar to `requestAnimationFrame` that we talked about, is `setTimeout`. `setTimeout` lets us schedule an event to happen after a specified number of milliseconds. The following example changes the color of a page after 2 seconds:

```html
<script>
document.body.style.background = "black";
setTimeout(function() {
    document.body.style.background = "green";
}, 2000);
</script>
```

Future events defined by `setTimeout` can be canceled by calling `clearTimeout` on it.

```html
var countDown = setTimeout(function() {
    console.log("BOOM!");
}, 500);

if (Math.random() < 0.5) { // 50% chance
  console.log("MacGruber!");
  clearTimeout(countDown);
}
```

We can use `cancelAnimationFrame` in a manner similar to `clearTimeout`. We can call it on a value returned by `requestAnimationFrame` to cancel that frame.

Finally, we can use `setInterval` and `clearInterval` to repeat a function every *X* milliseconds.

```html
var ticks = 0;
var clock = setInterval(function() {
    console.log("tick", ticks++);
    if (ticks == 10) {
        clearInterval(clock);
        console.log("stop.");
    }
}, 200);
```

## Debouncing

When we listen for events like `scroll` and `mousemove`, there is the potential for those events to fire off many times in rapid succession. We must be careful not to run any functions that take a long time to resolve or that use many resources as this can cause severe slowdown in our program's interface.

If we need to something nontrivial in an event handler, we should use `setTimeout` to make sure we aren't doing it too often. We call this pattern *Debouncing* and there a several ways to do it.

In the following example, we add an event listener to the `keyup` event with a timeout and cancel the timer if a user types faster than the timeout function.

```html
<textarea>Type something here...</textarea>
<script>
var textarea = document.querySelector("textarea");
var timeout;
textarea.addEventListener("keydown", function() {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
        console.log("You stopped typing.");
    }, 500);
});
</script>
```

In the next example, we use `setTimeout` to throttle how often an event can fire.

```html
<script>
function displayCoords(event) {
    document.body.textContent = "Mouse at " + event.pageX + ", " + event.pageY;
}

var scheduled = false, lastEvent;
addEventListener("mousemove", function(event) {
    lastEvent = event;
    if (!scheduled) {
        scheduled = true;
        setTimeout(function() {
            scheduled = false;
            displayCoords(lastEvent);
        }, 250);
    }
});
</script>
```

## Exercises

### Censored keyboard

In the sovereign nation of *Robikistan*, no one is allowed to say that the immortal, godlike ruler, Rob, sucks. To that end, all web browsers disable the letters "C", "K", "S", and "U" from  being typed into form fields. You have been tasked with writing the program that omits input of those letters in input fields.

Make a fork of the CodePen at http://codepen.io/rhlowe/pen/MYdyvQ and add the needed code to prevent the letters from being inserted into the text field.
