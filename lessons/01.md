# Node.js, NPM, Gulp, and Babel

In this section, we will.

1. set up our workspaces to use Node.js, NPM, and Babel
1. set up our editor to perform JavaScript lint tests.
1. create new files

# Pre-class Preperations

* [What is Node.js?](https://www.youtube.com/watch?v=pU9Q6oiQNd0)
* [A Beginner's Guide to NPM](http://www.sitepoint.com/beginners-guide-node-package-manager/)
* [What is Gulp?](http://brandonclapp.com/what-is-gulp-js-and-why-use-it/)
* [Lint and JavaScript](http://www.jamesshore.com/Blog/Lessons-Learned-Lint-and-Javascript.html)

## Node.js

**Node.js** is a web platform built on Google's JavaScript engine, V8. It provides a way to run a web server virtual machine via JavaScript. As a result, front-end developers can with relative ease, create full-stack web applications in JavaScript and write both front- and back end code in a language they already know.

Find out more at: https://nodejs.org/.

## NPM

**NPM** or the Node Package Manger is a tool that empowers a developer or team of developers to maintain and define JavaScript plugins and utilities and their dependencies.

Browse all the plugins here: https://www.npmjs.com/.

## Gulp

Gulp.js is a workflow automation tool. It provides an API for defining tasks such as moving or renaming files and running other plugins such as Babel, Browserfy, Karma, Sass, and image optimization on a variety of files.

Check it out at: http://gulpjs.com/

## Babel

Babel is a JavaScript compiler, it says so right on their website. Babel allows programmers to write future-facing and presently standard JavaScript and compile it down to code that will work on nearly any browser, regardless of support for current trends.

See it here: https://babeljs.io/

# Setting up a Workstation for Developing Modern Code

Install Node.js via the installer available at https://nodejs.org

Create a folder.

In the command line, go to that folder and run the following command:

```bash
npm init
```

Follow the on screen wizard.

Let's take a look at *package.json*.

Next, lets install some plugins. In the command line, enter the following commands,

```bash
npm install --save-dev gulp
npm install --save-dev gulp-sourcemaps
npm install --save-dev gulp-babel
npm install --save-dev gulp-watch
```

or just this command,

```bash
npm install --save-dev gulp gulp-sourcemaps gulp-babel gulp-watch
```

Next, in the root of our folder, let's create a file and call it `gulpfile.js` and lets add the following code.

```javascript
// Source of gulpfile.js

var gulp = require("gulp");
var babel = require("gulp-babel");

gulp.task('babel', function () {
    return gulp.src("src/*.js")
        .pipe(babel())
        .pipe(gulp.dest("dist"));
});

gulp.task('default', ['babel'], function() {});
```

In the command line, run the command,

```bash
gulp
```

and you should see something similar to,

```bash
[22:00:49] Using gulpfile gulpfile.js
[22:00:49] Starting 'babel'...
[22:00:49] Finished 'babel' after 9.72 ms
[22:00:49] Starting 'default'...
[22:00:49] Finished 'default' after 9.95 Î¼s
```

Next let's create a new JavaScript file called *src/variables.js*. Copy the functions `varTest()` and `letTest()` from the scope section. Run the `gulp` command again and let's see what happens.

We *should* see similar output from before, but now, if we look at our file system, we should also see a new folder titled 'dist'. Inside that folder, let's compare that version of *variables.js* to the one in src.

Isn't this great?

Let's make it greater. If I haven't mentioned it yet, I'll tell you now that great programmers are lazy, meaning we try not to repeat ourselves too many times. We don't want to manually run `gulp` each time we add a or modify a file, so let's set up a *watch* task.

Back in our gulpfile, let's add a new function,

```bash
gulp.task('watch', function() {
    gulp.watch('src/*.js', ['babel']);
});
```

Next, we'll add new array element to the default task.

```bash
gulp.task('default', ['babel', 'watch'], function() {});
```

If we've done everything correctly, when we run `gulp` next, the process will not terminate and any file we add or modify will automatically be processed. (If you want to manually end the process, just press `control + c`).

*Instructor will take class through a few coding exercises to verify everything works here.*

# Linting Our Code

Linting our code allows us to define specific rules we want to abide by as we code. A fully linted file ensures every developer touching a file follows the same basic rules about how they format their code.

Let's set up our machines to lint our code. This walk-through assumes you are using SublimeText 3. If you are using SublimeText 2, switch to [SublimeText 3](http://www.sublimetext.com/3). If you aren't using SublimeText at all, we will figure it out too.

In SublimeText, we need to first install [Package Control](https://packagecontrol.io/installation). *I'll come around and assist with anyone that needs help with this step.* With Package Control installed, we can press `command + shift + p` to run commands. We will use Package Control to install the *SublimeLinter* and *[SublimeLinter-eslint](https://github.com/roadhump/SublimeLinter-eslint)* plugins. **

*From this point, we'll handle each student's issues as needed. Once everyone is working, we'll do a in-class demo of the eslint directives and how and why to use them including .eslintrc files, adding rules in the file and inline in the js code.*

# Resources

- https://github.com/gulpjs/gulp/blob/master/docs/getting-started.md
- https://babeljs.io/docs/setup/#gulp
- http://eslint.org/

# Exercises

1) Write a blog post about what you've learned in this lesson.
